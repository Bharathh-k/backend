import json
import sys
from datetime import date
from multiprocessing import Pipe, Process

import google.generativeai as genai
import pandas as pd
from pymongo import MongoClient

from app.config import settings
from app.core.analysis_functions import (
    run_fundamental_script,
    run_technical_script,
    fetch_sector_analysis,
    run_news_script,
    run_sector_news_script,
    run_sector_hierarchy_script
)

def generate_stock_signal(news, sector, macro, fundamental, technical, ticker, client):
    system_prompt = """Generate a detailed, objective, and data-driven equity analysis, tailored specifically for Indian retail investors, without generic disclaimers or hedging language. Use precise, quantitative, and qualitative insights with actionable recommendations. Analysis must exclusively focus on equities listed on Indian exchanges (NSE/BSE).
The summaries for each bucket is provided below. Use them to generate a comprehensive analysis. All summaries have been generated by using the latest and accurate data and insights available. If any summary is missing, please fill it with the most relevant and recent data available so that the analysis is complete and actionable.
Only output the summary, strictly following the given format, with no introductions or closing statements from the AI.

Analysis Framework
1.  News Summary
2.  Sectoral News Summary
3.  Macroeconomic Summary
4.  Fundamental Summary
5.  Technical Summary

 Final Recommendation
- Action: [ Buy / Hold / Sell ]
- Conviction Level: [ High / Medium / Low ]
- Investment Horizon: [Short-term / Medium-term / Long-term]
- Strategy: (if applicable)

Explicit Reasoning:
- Specific growth targets
- Justification of valuation upside/downside %
- Key catalysts/events with timelines

Risk Management:
- Stop-loss and profit-booking points
- Key metrics/events to monitor

Quality Benchmarks:
- 1500+ words
- Peer comparisons and scenario projections
- Retail-friendly and actionable
"""

    with settings.get_prompt_path("unified_prompt_template.txt").open("r", encoding="utf-8") as f:
        template = f.read()

    filled_prompt = template.format(
        news_summary=news,
        sector_summary=sector,
        macro_summary=macro,
        fundamental_summary=fundamental,
        technical_summary=technical
    )

    genai.configure(api_key=settings.gemini_api_key)
    model = genai.GenerativeModel("gemini-2.5-pro", system_instruction=system_prompt)
    response = model.generate_content(filled_prompt)
    signal_text = response.text.strip()

    try:
        db = client['stock_signal']
        collection = db['stock_signal_summary']
        collection.update_one(
            {"stock": ticker},
            {
                "$set": {
                    "signal": signal_text,
                    "date": date.today().strftime("%Y-%m-%d")
                }
            },
            upsert=True
        )
        print(f" Stock signal for {ticker} saved successfully.")
    except Exception as e:
        print(f" Failed to save signal to MongoDB: {e}")
    
    return signal_text


def extract_json_from_equity_report(equity_report_text, ticker):
    # give me a code to read stock(11-06-2025) in the same directory and extract line matching the column SYMBOL to ticker
    df = pd.read_csv(settings.get_data_path("stock(11-06-2025).csv"))
    ticker_row = df[df['SYMBOL'] == ticker]
    roe = ticker_row['ROE'].values[0] if not ticker_row.empty else None
    roce = ticker_row['ROCE'].values[0] if not ticker_row.empty else None
    pe = ticker_row['Stock P/E'].values[0] if not ticker_row.empty else None
    sales_growth = ticker_row['Compounded Sales Growth'].values[0] if not ticker_row.empty else None
    profit_growth = ticker_row['Compounded Profit Growth'].values[0] if not ticker_row.empty else None
    df = pd.read_csv(settings.get_data_path("sector_hierarchy.csv"))
    ticker_row = df[df['SYMBOL'] == ticker]
    sector = ticker_row['Level 3'].values[0] if not ticker_row.empty else None
    json_extraction_prompt = '''
You are a financial data structuring assistant.

Below is a detailed equity analysis report. Your task is to extract key insights and convert the entire report into a valid JSON object, strictly following the structure below:

⚠️ Only output the JSON. Do not include explanations or markdown formatting like triple backticks.

JSON Structure

{
  "ticker": "string",
  "company_name": "string",
  "sections": {
    "news_summary": {
      "title": "string",
      "highlights": ["string", "..."]
    },
    "sectoral_summary": {
      "sector": {sector},
      "title": "string",
      "highlights": ["string", "..."]
    },
    "macroeconomic_summary": {
      "title": "string",
      "highlights": ["string", "..."]
    },
    "fundamental_summary": {
      "title": "string",
      "metrics": {
        "roe": {roe},
        "roce": {roce},
        "pe": {pe},
        "sales_growth": {sales_growth},
        "profit_growth": {profit_growth},
        "operating_cash_flow": {operating_cash_flow},
        "free_cash_flow": float,
        "debtor_days": int
      },
      "peer_comparison": [
        {
          "company": "string",
          "pe": float,
          "pb": float,
          "roe": "string",
          "roce": "string"
        }
      ]
    },
    "technical_summary": {
      "title": "string",
      "trend": "string",
      "support_zones": ["string"],
      "resistance_levels": ["string"],
      "indicators": {
        "supertrend": "string",
        "50_day_ema": "string",
        "macd": "string",
        "rsi": float
      }
    },
    "final_recommendation": {
      "action": "string",
      "buy_on_dips": boolean,
      "buy_levels": ["string"],
      "target_price_range": ["string"],
      "conviction_level": "string",
      "investment_horizon": "string",
      "strategy": "string",
      "stop_loss": "string",
      "profit_booking_zone": ["string"]
    },
    "risk_monitoring": ["string"]
  },
  "bite_sized_insights": ["string"]  (generate as many unique insights as possible, only from the report, do not hallucinate or add extra insights)
}
⚠️ Requirements:

All fields must be filled.

Use correct numeric types (float, int) and plain strings.

full_summary must exactly match the original report text.

Only return the JSON object with no extra text, code formatting, or explanations.

Now, here is the equity report for the stock {ticker}:

{equity_report}
'''.replace("{equity_report}", equity_report_text).replace("{ticker}", ticker).replace("{roe}", roe).replace("{roce}", roce).replace("{pe}", pe).replace("{sales_growth}", sales_growth).replace("{profit_growth}", profit_growth).replace("{sector}", sector)

    
    model = genai.GenerativeModel("gemini-2.5-flash") 
    response = model.generate_content(json_extraction_prompt)
    extracted_json = response.text.strip()

    return extracted_json

if __name__ == '__main__':
    ticker = input("Enter the ticker name: ").strip().upper()
    # ticker = sys.argv[1].strip().upper()

    client = MongoClient(settings.mongo_uri, tls=True, tlsAllowInvalidCertificates=True)
    db = client["stock_signal"]
    collection = db["stock_signal_summary"]

    stock_data = collection.find_one({"stock": ticker})
    if stock_data and stock_data.get("date") == date.today().strftime("%Y-%m-%d"):
        client.close()
        sys.exit(0)

    print(f"\nStarting analysis for {ticker} using Pipes...")

    parent_conn_f, child_conn_f = Pipe()
    parent_conn_t, child_conn_t = Pipe()
    parent_conn_s, child_conn_s = Pipe()
    parent_conn_n, child_conn_n = Pipe()
    parent_conn_se, child_conn_se = Pipe()
    parent_conn_h, child_conn_h = Pipe()

    p1 = Process(target=run_sector_hierarchy_script, args=(ticker, child_conn_h))
    p2 = Process(target=run_fundamental_script, args=(ticker, child_conn_f))
    p3 = Process(target=run_technical_script, args=(ticker, child_conn_t))
    p4 = Process(target=fetch_sector_analysis, args=(ticker, child_conn_s))
    p5 = Process(target=run_news_script, args=(ticker, child_conn_n))
    p6 = Process(target=run_sector_news_script, args=(ticker, child_conn_se))

    p1.start()
    child_conn_h.close()
    p1.join()
    print("Sector hierarchy process done")

    p2.start()
    p3.start()
    p4.start()
    p5.start()
    p6.start()

    child_conn_f.close()
    child_conn_t.close()
    child_conn_s.close()
    child_conn_n.close()
    child_conn_se.close()

    p2.join(); print("Fundamental process done")
    p3.join(); print("Technical process done")
    p4.join(); print("Macro process done")
    p5.join(); print("News process done")
    p6.join(); print("Sector News process done")

    print("\nAll processes complete. Collecting results...")

    fundamental_result = parent_conn_f.recv()
    technical_result = parent_conn_t.recv()
    sector_result = parent_conn_s.recv()
    news_result = parent_conn_n.recv()
    sector_news_result = parent_conn_se.recv()

    parent_conn_f.close()
    parent_conn_t.close()
    parent_conn_s.close()
    parent_conn_n.close()
    parent_conn_se.close()

    result = generate_stock_signal(
        news=news_result,
        sector=sector_news_result,
        macro=sector_result,
        fundamental=fundamental_result,
        technical=technical_result,
        ticker=ticker,
        client=client
    )

    if "Final Recommendation" in result:
        _, after_recommendation = result.split("Final Recommendation", 1)
    else:
        after_recommendation = ""

    final_rec_text = " Final Recommendation" + after_recommendation.strip()

    try:
        collection = db["final_recommendation"]
        collection.update_one(
            {"stock": ticker},
            {"$set": {"final_recommendation": final_rec_text}},
            upsert=True
        )
        print(f" Final recommendation for {ticker} saved to DB.")
    except Exception as e:
        print(f" Failed to save final recommendation to DB: {e}")


    signal_collection = db["stock_signal_summary"]
    equity_report_text = signal_collection.find_one({"stock": ticker}).get("signal", "")
    output_json = extract_json_from_equity_report(equity_report_text, ticker)
    output_json = json.loads(output_json)  
    collection = db["json"]
    collection.update_one(
            {"stock": ticker},
            {
                "$set": {
                    "extracted_json": output_json,
                    "date": date.today().strftime("%Y-%m-%d")
                }
            },
            upsert=True
        )
